package rss.rms.query;

import org.bson.conversions.Bson;

/**
 * Represents the build in RMS.
 * <p/>
 * This builder is designed to be an ultimate Java tool for building RMS queries.
 * <br/>
 * <p/>
 * The  query generated by the builder can be submitted to the rms for execution.
 * The builder is built in a way when it should be impossible to create a wrong query by doing an illegal series of calls.
 * <p/>
 * The builder is comprised of different sections, each of them is responsible for different query aspect, so that each of the parts can be reused.
 * As for now the following sections are supported:
 * <ul>
 * <li><b>filter</b> - the query filter</li>
 * <li><b>order</b> - the order of results to be fetched</li>
 * <li><b>layout</b> - the layout of results to be fetched</li>
 * <li><b>pageSize/skip</b> - paging related parameter</li>
 * <li><b>fetchCount</b> - information about the count to be fetched as a part of the query</li>
 * </ul>
 *
 * @author Mark Bramnik
 *         Date: 3/21/13
 *         Time: 3:56 PM
 * @since 1.0.0-9999
 */
public interface RmsQueryBuilder<T> {

    /**
     * Specify whether the total count of resources that adhere the filter condition exist in the underlying persistence storage.
     *
     * @param fetchCount - the number of objects in the persistence storage.
     * @return the builder instance
     */
    RmsQueryBuilder<T> fetchCount(boolean fetchCount);

    /**
     * Enter the order section. Optional parameter.
     * For performance reasons the values that appear in this section should be indexed.
     *
     * @return the order section builder
     */
    RmsQueryBuilder<T> order(Bson ... orderDescriptors);

    /**
     * Enter the page size. Optional parameter.
     * RMS query always return result in pages. This parameter allows to set the page size.
     * The page size can't be more than the max page size that RMS is able to proceed. For now its set to be 2000 results
     *
     * @param pageSize - the page size
     * @return the builder itself
     */
    RmsQueryBuilder<T> pageSize(Integer pageSize);

    /**
     * Skip parameter - how many records (documents) the rms should skip in advance before it retrieves the results.
     *
     * @param skip - integer - the skip records amount
     * @return the builder itself
     */
    RmsQueryBuilder<T> skip(Integer skip);

    /**
     * Enters the filtering section. Can contain logical conditions (boolean and/or) or concrete comparison conditions
     *
     * @return the builder itself
     */
    RmsQueryBuilder<T> filter(Bson filter);

    /**
     * Enters the layout section. Specifies which fields should be returned by the builder
     *
     * @return the builder itself
     */
//    RmsQueryBuilder<T> layout();

    /**
     * Constructs the {@link com.hp.maas.platform.rms.api.operation.get.GetResourcesRMSQuery} object use by the {@link com.hp.maas.platform.rms.api.RmsService#executeQuery RmsService.executeQuery}
     * method.
     *
     * @return The finished GetResourcesRMSQuery object
     */
//    GetResourcesRMSQuery<T> buildQuery();
    RmsQueryInformation getRmsQueryInformation();

    /**
     * Sets the {@link com.hp.maas.platform.rms.api.serializers.ResourceDeserializer} to use for converting the resources retrieved by the query from JSON
     * strings to objects of type T. Use this method to set a custom deserializer for your resources (this will probably
     * also require setting a custom serializer in insert and update operations).
     *
     * @param deserializer The deserializer to use when retrieving resources from the RMS, or null to use the default
     *                     deserializer
     * @return This builder
     */
//    RmsQueryBuilder<T> deserializer(ResourceDeserializer<T> deserializer);
}
